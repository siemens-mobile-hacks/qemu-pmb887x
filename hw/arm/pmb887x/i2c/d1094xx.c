/*
 * Dialog d1094xx / d1601xx
 * */
#define PMB887X_TRACE_ID		PMIC
#define PMB887X_TRACE_PREFIX	"d1094xx"

#include "qemu/osdep.h"
#include "hw/sysbus.h"
#include "hw/hw.h"
#include "exec/memory.h"
#include "qemu/main-loop.h"
#include "hw/qdev-properties.h"
#include "hw/i2c/i2c.h"
#include "hw/arm/pmb887x/trace.h"

#define TYPE_PMB887X_PMIC	"d1094xx"
#define PMB887X_PMIC(obj)	OBJECT_CHECK(pmb887x_pmic_t, (obj), TYPE_PMB887X_PMIC)

typedef struct pmb887x_pmic_t pmb887x_pmic_t;

struct pmb887x_pmic_t {
	I2CSlave parent_obj;
	uint32_t reg_id;
	uint8_t wcycle;
	uint8_t regs[256];
	uint32_t revision;
};

static const uint8_t regs_D1094EC[256] = { // Siemens CX75 & M75
	0x94, 0x00, 0x00, 0x00, 0x00, 0x08, 0x2F, 0x09, 0x00, 0xFF, 0x0E, 0x01, 0x06, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x44, 0x0C,
	0x00, 0x00, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0x09, 0x00, 0xFF, 0x0E, 0x01, 0x06, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x44, 0x0C,
	0x00, 0x00, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t regs_D1094ED[256] = { // Siemens x75, x85 platform
	0x25, 0x00, 0x10, 0x00, 0x00, 0x08, 0x2F, 0x09, 0x00, 0xFF, 0x06, 0x01, 0x06, 0x00, 0x10, 0x25,
	0x00, 0x00, 0x00, 0x00, 0x22, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
	0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x25,
	0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
	0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
	0x00, 0x10, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x30, 0x38, 0x00, 0x00, 0x40,
	0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
	0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
	0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
	0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
	0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25,
	0x7C, 0x3F, 0x3D, 0x3F, 0x01, 0x00, 0x34, 0x21, 0x0E, 0x0B, 0x25, 0xFF, 0xFF, 0x01, 0x25, 0x25,
	0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 
};

static const uint8_t regs_D1601AA[256] = { // Siemens E71
	0x86, 0x00, 0x00, 0x00, 0x00, 0x04, 0x2F, 0x09, 0x00, 0xFF, 0x06, 0x01, 0x06, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x45, 0x0C,
	0x00, 0x00, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0x09, 0x00, 0xFF, 0x06, 0x01, 0x06, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x45, 0x0C,
	0x00, 0x00, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static int pmic_event(I2CSlave *s, enum i2c_event event) {
	pmb887x_pmic_t *p = PMB887X_PMIC(s);

    switch (event) {
		case I2C_START_SEND:
			// Nothing
			break;
		
		case I2C_START_RECV:
		case I2C_NACK:
		case I2C_FINISH:
			p->wcycle = 0;
			break;

		case I2C_START_SEND_ASYNC:
			// Nothing
			break;
	}
    
    return 0;
}

static uint8_t pmic_recv(I2CSlave *s) {
	pmb887x_pmic_t *p = PMB887X_PMIC(s);
	
	uint8_t data = p->regs[p->reg_id];
	DPRINTF("read reg %02X: %02X\n", p->reg_id, data);
	p->reg_id = (p->reg_id + 1) % ARRAY_SIZE(p->regs);
	
	return data;
}

static int pmic_send(I2CSlave *s, uint8_t data) {
	pmb887x_pmic_t *p = PMB887X_PMIC(s);
	
	if (p->wcycle == 0) {
		p->reg_id = data % ARRAY_SIZE(p->regs);
	} else {
		DPRINTF("write reg %02X: %02X\n", p->reg_id, data);
		p->regs[p->reg_id] = data;
		p->reg_id = (p->reg_id + 1) % ARRAY_SIZE(p->regs);
	}
	
	p->wcycle++;
	
    return 0;
}

static void pmic_realize(DeviceState *dev, Error **errp) {
	pmb887x_pmic_t *p = PMB887X_PMIC(dev);
	if (p->revision == 0xEC) {
		memcpy(p->regs, regs_D1094EC, sizeof(regs_D1094EC));
	} else if (p->revision == 0xED) {
		memcpy(p->regs, regs_D1094ED, sizeof(regs_D1094ED));
	} else if (p->revision == 0xAA) {
		memcpy(p->regs, regs_D1601AA, sizeof(regs_D1601AA));
	} else {
		hw_error("pmb887x-pmic: unknown revision %02X", p->revision);
	}
}

static const Property pmic_properties[] = {
	DEFINE_PROP_UINT32("revision", pmb887x_pmic_t, revision, 0xAA),
};

static void pmic_class_init(ObjectClass *klass, void *data) {
	DeviceClass *dc = DEVICE_CLASS(klass);
	device_class_set_props(dc, pmic_properties);
	dc->realize = pmic_realize;
	
    I2CSlaveClass *k = I2C_SLAVE_CLASS(klass);
    k->event = &pmic_event;
    k->recv = &pmic_recv;
    k->send = &pmic_send;
}

static const TypeInfo pmic_info = {
    .name          	= TYPE_PMB887X_PMIC,
    .parent        	= TYPE_I2C_SLAVE,
    .instance_size 	= sizeof(pmb887x_pmic_t),
    .class_init    	= pmic_class_init,
};

static void pmic_register_types(void) {
	type_register_static(&pmic_info);
}
type_init(pmic_register_types)
